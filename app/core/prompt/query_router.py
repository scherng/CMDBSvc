from typing import Dict, Any, Union, List
from app.db.connector.database_interface import DatabaseInterface
from app.db.data_operator.user_operator import UserOperator
from app.db.data_operator.application_operator import ApplicationOperator
from app.db.models import User, Application
import logging

logger = logging.getLogger(__name__)


class QueryRouter:
    """Routes MongoDB queries generated by LLM to appropriate data operators."""

    def __init__(self, database: DatabaseInterface):
        self.database = database

        # Initialize operators with their respective collections
        users_collection = database.get_collection("users")
        apps_collection = database.get_collection("applications")

        self.user_operator = UserOperator(users_collection, apps_collection)
        self.app_operator = ApplicationOperator(apps_collection, users_collection)

        # Map collection names to operators
        self.operators = {
            "users": self.user_operator,
            "applications": self.app_operator,
        }

    def execute(self, mongo_query: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a MongoDB query and return formatted results."""
        try:
            collection_name = mongo_query.get("collection")

            if not collection_name:
                return {
                    "error": "Missing 'collection' field in query",
                    "query": mongo_query
                }

            if collection_name not in self.operators:
                return {
                    "error": f"Unsupported collection: {collection_name}. Supported collections: {list(self.operators.keys())}",
                    "query": mongo_query
                }

            operator = self.operators[collection_name]

            # Execute the query
            results = operator.execute_query(mongo_query)

            # Format the response
            response = {
                "collection": collection_name,
                "query": mongo_query,
                "count": len(results) if isinstance(results, list) else (1 if isinstance(results, int) else 0),
                "results": self._format_results(results, collection_name)
            }

            logger.info(f"Query executed successfully on collection '{collection_name}', returned {response['count']} results")
            return response

        except Exception as e:
            logger.error(f"Error executing query: {e}")
            return {
                "error": f"Query execution failed: {str(e)}",
                "query": mongo_query
            }

    def _format_results(self, results: Union[List[User], List[Application], List[Dict[str, Any]], int],
                       collection_name: str) -> Union[List[Dict[str, Any]], int]:
        """Format results for API response."""
        try:
            # If it's a count operation, return the count
            if isinstance(results, int):
                return results

            # If it's a list of Pydantic models, convert to dict
            if isinstance(results, list) and len(results) > 0:
                if isinstance(results[0], (User, Application)):
                    # Convert Pydantic models to dictionaries
                    return [item.model_dump() for item in results]
                elif isinstance(results[0], dict):
                    # Already dictionaries (from aggregation)
                    return results

            # Empty list or other cases
            return results if isinstance(results, list) else []

        except Exception as e:
            logger.error(f"Error formatting results: {e}")
            return []

    def get_supported_collections(self) -> List[str]:
        """Get list of supported collection names."""
        return list(self.operators.keys())

    def health_check(self) -> Dict[str, Any]:
        """Check if all operators are working correctly."""
        try:
            health_status = {
                "database_connected": self.database.health_check(),
                "supported_collections": self.get_supported_collections(),
                "operators_initialized": len(self.operators) > 0
            }

            logger.info("QueryRouter health check completed")
            return {
                "healthy": all(health_status.values()),
                "details": health_status
            }
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return {
                "healthy": False,
                "error": str(e)
            }