from typing import List, Optional, Dict, Any, Union
from app.db.models import User, UserCreate
from app.db.collection_operator.collection_interface import CollectionInterface
import logging

logger = logging.getLogger(__name__)


class UserOperator:
    def __init__(self, users_collection: CollectionInterface, apps_collection: CollectionInterface):
        self.collection = users_collection
        self.apps_collection = apps_collection

    def create(self, user_data: UserCreate) -> User:
        try:
            new_user = User.create_new(**user_data.model_dump())

            result = self.collection.insert_one(new_user.to_mongo())

            if result.inserted_id:
                logger.info(f"User created with ci_id: {new_user.ci_id}")
                return new_user
            else:
                raise Exception("Failed to insert user")

        except Exception as e:
            logger.error(f"Error creating user: {e}")
            raise

    def find_by_ci_id(self, ci_id: str) -> Optional[User]:
        try:
            user_data = self.collection.find_one({"ci_id": ci_id})
            if user_data:
                return User.from_mongo(user_data)
            return None
        except Exception as e:
            logger.error(f"Error finding user by ci_id {ci_id}: {e}")
            return None

    def find_by_user_id(self, user_id: str) -> Optional[User]:
        try:
            user_data = self.collection.find_one({"user_id": user_id})
            if user_data:
                return User.from_mongo(user_data)
            return None
        except Exception as e:
            logger.error(f"Error finding user by user_id {user_id}: {e}")
            return None

    def find_by_name(self, name: str) -> Optional[User]:
        try:
            user_data = self.collection.find_one({"name": name})
            if user_data:
                return User.from_mongo(user_data)
            return None
        except Exception as e:
            logger.error(f"Error finding user by name {name}: {e}")
            return None

    def find_all(self, skip: int = 0, limit: int = 100) -> List[User]:
        try:
            cursor = self.collection.find().skip(skip).limit(limit)
            users = []
            for user_data in cursor:
                users.append(User.from_mongo(user_data))
            return users
        except Exception as e:
            logger.error(f"Error finding all users: {e}")
            return []
        
    def find_by_team(self, team: str) -> List[User]:
        try:
            cursor = self.collection.find({"team": team})
            users = []
            for user_data in cursor:
                users.append(User.from_mongo(user_data))
            return users
        except Exception as e:
            logger.error(f"Error finding users by team {team}: {e}")
            return []

    def find_by_mfa_enabled(self, mfa_enabled: bool) -> List[User]:
        try:
            cursor = self.collection.find({"mfa_enabled": mfa_enabled})
            users = []
            for user_data in cursor:
                users.append(User.from_mongo(user_data))
            return users
        except Exception as e:
            logger.error(f"Error finding users by MFA status: {e}")
            return []

    def find_by_filter(self, filter_dict: Dict[str, Any], limit: int = 100) -> List[User]:
        """Find users by arbitrary filter criteria."""
        try:
            cursor = self.collection.find(filter_dict).limit(limit)
            users = []
            for user_data in cursor:
                users.append(User.from_mongo(user_data))
            logger.info(f"Found {len(users)} users matching filter")
            return users
        except Exception as e:
            logger.error(f"Error finding users by filter {filter_dict}: {e}")
            return []

    def execute_aggregation(self, pipeline: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Execute aggregation pipeline on users collection."""
        try:
            results = self.collection.aggregate(pipeline)
            logger.info(f"Aggregation executed on users collection, returned {len(results)} results")
            return results
        except Exception as e:
            logger.error(f"Error executing aggregation on users collection: {e}")
            return []

    def execute_query(self, query: Dict[str, Any]) -> Union[List[User], List[Dict[str, Any]], int]:
        """Execute a MongoDB query generated by LLM on users collection."""
        try:
            if "pipeline" in query:
                # Aggregation pipeline
                pipeline = query["pipeline"]
                return self.execute_aggregation(pipeline)

            elif "query" in query:
                # Simple find query
                filter_dict = query["query"]
                limit = query.get("limit", 100)

                # Check if this is a count operation
                if query.get("operation") == "count" or query.get("count"):
                    return self.collection.count_documents(filter_dict)

                return self.find_by_filter(filter_dict, limit)

            elif "count" in query:
                # Count operation
                filter_dict = query.get("filter", {})
                return self.collection.count_documents(filter_dict)

            else:
                logger.error(f"Unsupported query format: {query}")
                return []

        except Exception as e:
            logger.error(f"Error executing query on users collection: {e}")
            return []